name: Deploy to Development (Podman - systemd-first)

on:
  workflow_dispatch:

jobs:
  build-and-deploy-development:
    runs-on: ubuntu-latest
    environment: development
    if: github.ref_name == 'develop'

    steps:
    - name: Validate branch
      run: |
        if [ "${{ github.ref_name }}" != "develop" ]; then
          echo "This workflow can only be triggered from the 'develop' branch."
          echo "Current branch: ${{ github.ref_name }}"
          exit 1
        fi
        echo "Branch validation passed. Running on 'develop' branch."

    - name: Checkout code
      uses: actions/checkout@v4

    - name: Assert required GitHub Secrets are present
      run: |
        set -euo pipefail
        missing=0
        if [ -z "${{ secrets.POSTGRES_DB }}" ]; then echo "Missing secret: POSTGRES_DB" >&2; missing=1; fi
        if [ -z "${{ secrets.POSTGRES_USER }}" ]; then echo "Missing secret: POSTGRES_USER" >&2; missing=1; fi
        if [ -z "${{ secrets.POSTGRES_PASSWORD }}" ]; then echo "Missing secret: POSTGRES_PASSWORD" >&2; missing=1; fi
        if [ -z "${{ secrets.TELEGRAM_BOT_TOKEN }}" ]; then echo "Missing secret: TELEGRAM_BOT_TOKEN" >&2; missing=1; fi
        if [ -z "${{ secrets.TELEGRAM_BOT_USERNAME }}" ]; then echo "Missing secret: TELEGRAM_BOT_USERNAME" >&2; missing=1; fi
        if [ $missing -ne 0 ]; then
          echo "One or more required secrets are missing. Aborting." >&2
          exit 1
        fi

    - name: Check deploy sudoers on host (fast check)
      uses: appleboy/ssh-action@v0.1.10
      with:
        host: ${{ vars.VPS_HOST }}
        username: ${{ secrets.VPS_USER }}
        key: ${{ secrets.VPS_SSH_KEY }}
        script: |
          set -euo pipefail
          # Non-interactive sudo capability check for the privileged wrapper
          if ! sudo -n -l 2>/dev/null | grep -q '/usr/local/bin/geohod-deploy-systemd.sh'; then
            echo "ERROR: deploy user does not have NOPASSWD sudo for /usr/local/bin/geohod-deploy-systemd.sh" >&2
            echo "Please add via visudo (example):" >&2
            echo "  deployuser ALL=(root) NOPASSWD: /usr/local/bin/geohod-deploy-systemd.sh" >&2
            exit 1
          fi
          echo "OK: deploy user can run the privileged wrapper via sudo"

    - name: Set up JDK 23
      uses: actions/setup-java@v4
      with:
        java-version: '23'
        distribution: 'temurin'

    - name: Cache Gradle packages
      uses: actions/cache@v4
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
        key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
        restore-keys: |
          ${{ runner.os }}-gradle-

    - name: Install Podman
      run: |
        sudo apt-get update
        sudo apt-get install -y podman

    - name: Build with Gradle
      run: ./gradlew build -x test

    - name: Set image tags for development
      run: |
        # Validate GITHUB_SHA is available
        if [ -z "$GITHUB_SHA" ]; then
          echo "❌ GITHUB_SHA is not set"
          exit 1
        fi

        COMMIT_SHA=${GITHUB_SHA:0:7}

        # Validate commit SHA format
        if [[ ! "$COMMIT_SHA" =~ ^[a-f0-9]{7}$ ]]; then
          echo "❌ Invalid commit SHA format: $COMMIT_SHA"
          exit 1
        fi

        IMAGE_TAR="geohod-backend-dev-${COMMIT_SHA}.tar.gz"
        IMAGE_TAR_LATEST="geohod-backend-dev-latest.tar.gz"

        echo "COMMIT_SHA=${COMMIT_SHA}" >> $GITHUB_ENV
        echo "PRIMARY_TAG=geohod-backend:dev-${COMMIT_SHA}" >> $GITHUB_ENV
        echo "LATEST_TAG=geohod-backend:dev-latest" >> $GITHUB_ENV
        echo "IMAGE_TAR=${IMAGE_TAR}" >> $GITHUB_ENV
        echo "IMAGE_TAR_LATEST=${IMAGE_TAR_LATEST}" >> $GITHUB_ENV

        echo "✅ Generated development tags and artifact names: ${COMMIT_SHA}, ${IMAGE_TAR}, ${IMAGE_TAR_LATEST}"

    - name: Build Podman image with dynamic tags
      run: |
        podman build -f .github/Dockerfile -t ${{ env.PRIMARY_TAG }} -t ${{ env.LATEST_TAG }} .

    - name: Save Podman image
      run: |
        set -euo pipefail
        # Ensure env produced by previous step is available
        if [ -z "${PRIMARY_TAG:-}" ]; then
          echo "PRIMARY_TAG not set" >&2
          exit 1
        fi
        if [ -z "${LATEST_TAG:-}" ]; then
          echo "LATEST_TAG not set" >&2
          exit 1
        fi
        if [ -z "${IMAGE_TAR:-}" ]; then
          echo "IMAGE_TAR not set" >&2
          exit 1
        fi
        if [ -z "${IMAGE_TAR_LATEST:-}" ]; then
          echo "IMAGE_TAR_LATEST not set" >&2
          exit 1
        fi

        echo "Saving image '${PRIMARY_TAG}' and '${LATEST_TAG}' to tarball: ${IMAGE_TAR}"
        # Save both tags into a single tarball so 'podman load' on the server restores both tags.
        podman save "${PRIMARY_TAG}" "${LATEST_TAG}" | gzip > "${IMAGE_TAR}"

        # Create a -latest copy filename to satisfy existing scp / staging expectations
        cp -f "${IMAGE_TAR}" "${IMAGE_TAR_LATEST}" || true

        echo "Created artifacts:"
        ls -lh "${IMAGE_TAR}" "${IMAGE_TAR_LATEST}" || true

    - name: Secret check (already performed earlier)
      run: |
        echo "Secret check moved earlier in the workflow"

    - name: Render env file from GitHub Secrets (runner-only; not committed)
      run: |
        set -euo pipefail
        cat > geohod-dev.env <<EOF
        POSTGRES_DB=${{ secrets.POSTGRES_DB }}
        POSTGRES_USER=${{ secrets.POSTGRES_USER }}
        POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
        TELEGRAM_BOT_TOKEN=${{ secrets.TELEGRAM_BOT_TOKEN }}
        TELEGRAM_BOT_USERNAME=${{ secrets.TELEGRAM_BOT_USERNAME }}
        CORS_ALLOWED_ORIGINS=${{ vars.CORS_ALLOWED_ORIGINS }}
        GEOHOD_CREATED_EVENT_LINK_TEMPLATE=${{ vars.GEOHOD_CREATED_EVENT_LINK_TEMPLATE }}
        GEOHOD_REVIEW_LINK_TEMPLATE=${{ vars.GEOHOD_REVIEW_LINK_TEMPLATE }}
        EOF
        # Restrict permissions on runner artifact to be conservative initially
        chmod 600 geohod-dev.env

    - name: Pack deployment artifacts (runner-side)
      run: |
        set -euo pipefail
        # Package a single deploy artifact tarball that the runner user can create/read.
        # This avoids appleboy/scp's internal tar step which may run as a different user
        # and fail on strict file permissions for secrets (tar: Permission denied).
        ARTIFACT="geohod-deploy-artifacts-${COMMIT_SHA}.tar.gz"
        echo "Creating deployment artifact: ${ARTIFACT}"

        # Verify the image tar exists
        if [ -z "${IMAGE_TAR:-}" ] || [ ! -f "${IMAGE_TAR}" ]; then
          echo "ERROR: expected image tar missing: ${IMAGE_TAR:-<unset>}" >&2
          ls -lah || true
          exit 1
        fi

        # Create the archive as the runner user (has permission to read geohod-dev.env)
        tar -czf "${ARTIFACT}" \
          "${IMAGE_TAR}" "${IMAGE_TAR_LATEST}" \
          deployments/dev/systemd/*.service \
          geohod-dev.env \
          deployments/shared/healthcheck.sh

        echo "Pack complete; artifact size:"
        ls -lh "${ARTIFACT}" || true
        # Export artifact name for later steps
        echo "ARTIFACT=${ARTIFACT}" >> $GITHUB_ENV

    - name: Copy deployment artifact to server (single tarball)
      uses: appleboy/scp-action@v0.1.7
      with:
        host: ${{ vars.VPS_HOST }}
        username: ${{ secrets.VPS_USER }}
        key: ${{ secrets.VPS_SSH_KEY }}
        source: |
          ${{ env.ARTIFACT }}
        target: "~/geohod-backend-dev/"

    - name: Remove runner artifacts (sensitive cleanup)
      run: |
        set -euo pipefail
        # Remove the generated env file
        rm -f geohod-dev.env || true

        # Remove image tarballs and the deployment artifact created for transfer
        rm -f "${IMAGE_TAR:-}" "${IMAGE_TAR_LATEST:-}" || true
        rm -f "${ARTIFACT:-}" || true

        # Double-check no accidental leftover env file
        if [ -f geohod-dev.env ]; then
          echo "Warning: failed to remove geohod-dev.env" >&2
          exit 1
        fi

    - name: Invoke privileged deploy wrapper on server
      uses: appleboy/ssh-action@v0.1.10
      with:
        host: ${{ vars.VPS_HOST }}
        username: ${{ secrets.VPS_USER }}
        key: ${{ secrets.VPS_SSH_KEY }}
        script: |
          set -euo pipefail
          STAGING_DIR="/tmp/geohod-deploy-staging"
          mkdir -p "$STAGING_DIR"
          cd ~/geohod-backend-dev

          # Unpack the single artifacts tarball (created by the runner) into staging
          artifact_candidate=$(ls -1 geohod-deploy-artifacts-*.tar.gz 2>/dev/null | head -n1 || true)
          if [ -n "$artifact_candidate" ]; then
            echo "Extracting artifact: $artifact_candidate -> $STAGING_DIR"
            tar -xzf "$artifact_candidate" -C "$STAGING_DIR"
          else
            echo "ERROR: deployment artifact missing on host (expected geohod-deploy-artifacts-*.tar.gz)" >&2
            exit 1
          fi

          # Ensure unit files are available under staging/systemd
          mkdir -p "$STAGING_DIR/systemd"
          mv -f "$STAGING_DIR"/*.service "$STAGING_DIR/systemd/" 2>/dev/null || true

          # Ensure healthcheck helper is executable
          if [ -f "$STAGING_DIR/healthcheck.sh" ]; then
            chmod +x "$STAGING_DIR/healthcheck.sh"
          fi

          echo "Invoking privileged deploy wrapper (sudo) to install systemd units and load image..."
          sudo /usr/local/bin/geohod-deploy-systemd.sh install "$STAGING_DIR"

          # Optional: run healthcheck if helper present
          if [ -x "$STAGING_DIR/healthcheck.sh" ]; then
            echo "Running post-deploy healthcheck..."
            "$STAGING_DIR/healthcheck.sh" dev 60 || true
          fi

          # Cleanup staging artifacts left in /tmp (wrapper already loaded image and copied env)
          rm -rf "$STAGING_DIR"
          # Remove any tarball variants from runner directory
          rm -f geohod-backend-dev-*.tar.gz || true